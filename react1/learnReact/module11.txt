MODULE 11: PERFORMANCE OPTIMIZATION IN REACT
============================================

11.1 PERFORMANCE MINDSET
------------------------
- Optimize for user-perceived performance (TTFB, FCP, TTI, CLS, TBT, LCP).
- Measure before/after; avoid premature optimization.
- Separate client state vs. server state to limit rerenders.

Key Metrics
-----------
- FPS: target ~60fps for interactions.
- React render timings: render count, render duration.
- Bundle size & chunk splitting.
- Network waterfalls (blocking resources, redundant calls).


11.2 RENDERING COSTS & RE-RENDERS
---------------------------------

Identify Causes of Re-renders
-----------------------------
- Props identity changes (new object/array/function each render).
- Context value changes (all consumers rerender by default).
- State updates at parent level.
- Inline style/function recreations passed down.

React DevTools Profiler
-----------------------
- Record interactions to see what re-rendered and why.
- Watch "rendered by" to trace prop/context chains.


11.3 `React.memo` BASICS
------------------------
- Wrap pure components to skip rerenders when props are shallow-equal.
- Works best for stable props; avoid on components with frequent changing props unless heavy render.

Example
-------
```jsx
import { memo } from 'react';

const TodoItem = memo(function TodoItem({ todo, onToggle }) {
  return (
    <li>
      <label>
        <input type="checkbox" checked={todo.done} onChange={() => onToggle(todo.id)} />
        {todo.title}
      </label>
    </li>
  );
});
```

When NOT to use
---------------
- Very small components with cheap renders.
- When props change every render (memo adds overhead).


11.4 STABLE CALLBACKS: `useCallback`
------------------------------------
- Provides stable function identity to avoid child rerenders or effect retriggers.

Example
-------
```jsx
function TodoList({ todos, onToggle }) {
  const sorted = useMemo(() => [...todos].sort((a, b) => a.title.localeCompare(b.title)), [todos]);
  const handleToggle = useCallback((id) => onToggle(id), [onToggle]);

  return sorted.map(todo => (
    <TodoItem key={todo.id} todo={todo} onToggle={handleToggle} />
  ));
}
```

Common Pitfall
--------------
- Overusing `useCallback` when children are not memoized; no benefit.


11.5 EXPENSIVE CALCULATIONS: `useMemo`
--------------------------------------
- Memoize derived data; ensure calculation is actually expensive.

Example
-------
```jsx
const filtered = useMemo(() => items.filter(i => matches(i, query)), [items, query]);
```

Pitfalls
--------
- useMemo does not cache between renders if dependencies change frequently.
- Don’t memoize trivial computations.


11.6 CONTEXT PERFORMANCE
------------------------

Problems
--------
- Any value change triggers rerender of all consumers.

Solutions
---------
- Split context: separate read-heavy from write functions.
- Provide stable object references (memoize value).
- Use selector-based context patterns or libraries (e.g., `use-context-selector`).

Pattern
-------
```jsx
const CountContext = createContext();
const CountDispatchContext = createContext();

function CounterProvider({ children }) {
  const [count, setCount] = useState(0);
  const inc = useCallback(() => setCount(c => c + 1), []);
  return (
    <CountContext.Provider value={count}>
      <CountDispatchContext.Provider value={inc}>
        {children}
      </CountDispatchContext.Provider>
    </CountContext.Provider>
  );
}
```


11.7 STATE PLACEMENT & NORMALIZATION
------------------------------------
- Keep state as local as possible; avoid lifting excessively.
- Normalize collections (by id) to avoid full array rewrites.

Example Normalization
---------------------
```jsx
const [byId, setById] = useState({});
const [allIds, setAllIds] = useState([]);
// Updates only affected entries
```


11.8 AVOID UNNECESSARY RECONCILIATION
-------------------------------------
- Provide stable `key` for lists; avoid index keys for reordering lists.
- Avoid creating new elements conditionally when toggling visibility; prefer conditional render of same subtree when possible.


11.9 ASYNC & TRANSITIONS (REACT 18)
-----------------------------------
- `useTransition` to mark updates as non-urgent, keeping input responsive.
- `startTransition` for non-urgent state updates (e.g., filtering large lists).

Example
-------
```jsx
const [isPending, startTransition] = useTransition();

function handleFilter(value) {
  setQuery(value);
  startTransition(() => {
    setFiltered(applyFilter(data, value));
  });
}
```


11.10 DEBOUNCE & THROTTLE
-------------------------
- Debounce input-driven expensive operations (search, resize handlers).
- Use `useRef` to store timers; or utility libs like lodash.debounce.

Example Debounce
----------------
```jsx
function useDebouncedValue(value, delay = 200) {
  const [debounced, setDebounced] = useState(value);
  useEffect(() => {
    const t = setTimeout(() => setDebounced(value), delay);
    return () => clearTimeout(t);
  }, [value, delay]);
  return debounced;
}
```


11.11 VIRTUALIZATION
--------------------
- Use virtualization for long lists (e.g., `react-window`, `react-virtual`).

Example (react-window)
----------------------
```bash
npm install react-window
```
```jsx
import { FixedSizeList } from 'react-window';

function Row({ index, style, data }) {
  const item = data[index];
  return <div style={style}>{item.name}</div>;
}

function UserList({ users }) {
  return (
    <FixedSizeList
      height={400}
      width={360}
      itemCount={users.length}
      itemSize={48}
      itemData={users}
    >
      {Row}
    </FixedSizeList>
  );
}
```


11.12 BUNDLE OPTIMIZATION
-------------------------

Code Splitting
--------------
- Use `React.lazy` + `Suspense` for routes and heavy components.
```jsx
const Settings = lazy(() => import('./Settings'));
```

Dynamic Imports for Heavy Deps
------------------------------
- Import charts/editors only when needed.

Tree Shaking
------------
- Prefer ESM builds; avoid importing whole libraries (e.g., `import { debounce } from 'lodash-es'` vs `import _ from 'lodash'`).

Analyze Bundle
--------------
- Use tools: `vite --analyze`, `rollup-plugin-visualizer`, `webpack-bundle-analyzer`.


11.13 IMAGE & ASSET OPTIMIZATION
--------------------------------
- Serve modern formats (WebP/AVIF) with fallbacks.
- Use responsive images (`srcset`, `sizes`) and width-constrained images.
- Lazy-load below-the-fold images (`loading="lazy"`).
- Preload critical assets (fonts, hero images) judiciously.


11.14 AVOIDING EXTRA NETWORK WORK
---------------------------------
- Cache server state (React Query); set `staleTime` appropriately.
- Debounce search requests; cancel stale fetches with AbortController.
- Batch requests when possible.

Abort Controller Pattern
------------------------
```jsx
useEffect(() => {
  const controller = new AbortController();
  fetch(`/api/search?q=${query}`, { signal: controller.signal })
    .then(r => r.json())
    .then(setResults)
    .catch((err) => { if (err.name !== 'AbortError') setError(err); });
  return () => controller.abort();
}, [query]);
```


11.15 DEVTOOLS & DIAGNOSTICS
----------------------------
- React DevTools Profiler: measure commit times, see render reasons.
- React DevTools "Highlight updates" to spot rerenders.
- Browser Performance panel: flamecharts, layout/paint costs.
- Lighthouse: LCP, CLS, TBT insights.


11.16 COMMON PITFALLS & FIXES
-----------------------------
- Passing new object/array literals to memoized children → extract/memoize.
- Recomputing expensive derived data each render → useMemo.
- Heavy list rendering → virtualization or windowing.
- Single large context causing broad rerenders → split context/selectors.
- Unbounded effect work (event listeners, intervals) → clean up properly.
- Large bundles from big libraries → tree-shake or dynamic import.


11.17 PRACTICE EXERCISES
------------------------
1) Memo & Callbacks
- Given a todo list with filters, apply React.memo + useCallback to reduce rerenders; verify with Profiler.

2) Debounced Search
- Build search input that debounces API calls and cancels stale requests.

3) Virtualized Table
- Render 10k rows with react-window; add sticky header and smooth scroll.

4) Code Split Route
- Lazy-load a heavy chart page; show Suspense fallback; measure bundle change.

5) Context Split
- Refactor a single AppContext into separate contexts (theme, user, settings); confirm fewer rerenders.


11.18 CHECKLIST
---------------
- [ ] Are expensive computations memoized or moved out of render?
- [ ] Are callbacks stable for memoized children?
- [ ] Is state colocated and normalized?
- [ ] Are contexts split and memoized?
- [ ] Are large lists virtualized?
- [ ] Are heavy components code-split?
- [ ] Are images optimized and lazy-loaded?
- [ ] Are network calls cached/debounced and abortable?
- [ ] Have you profiled before/after changes?


NEXT STEPS
----------
You finished Module 11! You can now:
✓ Diagnose rerenders and measure performance
✓ Use React.memo/useCallback/useMemo effectively
✓ Split context and colocate state for fewer rerenders
✓ Apply transitions, debounce/throttle, and virtualization
✓ Optimize bundles, assets, and network work

Next up: Module 12 – TypeScript with React.
