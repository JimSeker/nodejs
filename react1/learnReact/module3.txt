MODULE 3: COMPONENT LIFECYCLE AND EFFECTS
=========================================

3.1 useEffect HOOK
------------------

What are Side Effects?
----------------------
Side effects are operations that affect something outside the component:
- Fetching data from an API
- Subscribing to external events
- Manually changing the DOM
- Setting up timers
- Logging to console
- Reading/writing to localStorage
- WebSocket connections

In React, the component function should be pure (same input → same output).
Side effects should happen in useEffect, not during render.


Introduction to useEffect
--------------------------

useEffect lets you synchronize a component with external systems.

Basic syntax:
```jsx
import { useEffect } from 'react';

function Component() {
  useEffect(() => {
    // Side effect code here
  });
  
  return <div>Component</div>;
}
```

Key concepts:
- Runs after render (after DOM updates)
- Runs on every render by default
- Can return cleanup function
- Can be controlled with dependencies


Effect Timing
-------------

1. Component Lifecycle Phases
------------------------------
- Mount: Component added to DOM
- Update: Component re-rendered due to state/props change
- Unmount: Component removed from DOM

2. When useEffect Runs
-----------------------
```jsx
function Component() {
  console.log('1. Render phase');
  
  useEffect(() => {
    console.log('2. Effect runs after render');
    
    return () => {
      console.log('3. Cleanup runs before next effect or unmount');
    };
  });
  
  return <div>Component</div>;
}

// Order of execution:
// 1. Render phase
// 2. DOM updated
// 3. Effect runs after render
// (on next render)
// 4. Cleanup runs
// 5. Render phase
// 6. Effect runs after render
```


Effect Dependencies
-------------------

The dependency array controls when the effect runs.

1. No Dependency Array (Runs on Every Render)
----------------------------------------------
```jsx
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    console.log('Runs after every render');
  });
  // ⚠️ No dependency array - runs on every render!
  
  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}
```

2. Empty Dependency Array (Runs Once on Mount)
-----------------------------------------------
```jsx
function Component() {
  useEffect(() => {
    console.log('Runs once on mount');
  }, []);
  // ✅ Empty array - runs only once when component mounts
  
  return <div>Component</div>;
}
```

3. With Dependencies (Runs When Dependencies Change)
----------------------------------------------------
```jsx
function Component() {
  const [count, setCount] = useState(0);
  const [name, setName] = useState('');
  
  useEffect(() => {
    console.log('Runs when count changes');
  }, [count]);
  // ✅ Only re-runs when count changes
  
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Count: {count}</button>
      <input value={name} onChange={(e) => setName(e.target.value)} />
    </div>
  );
}
```

4. Multiple Dependencies
-------------------------
```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  
  useEffect(() => {
    console.log('Runs when userId OR posts change');
    // Effect code
  }, [userId, posts]);
  
  return <div>User Profile</div>;
}
```


Cleanup Functions
-----------------

Return a function from useEffect to clean up resources.

1. Why Cleanup?
---------------
- Prevent memory leaks
- Cancel pending requests
- Unsubscribe from events
- Clear timers
- Close connections

2. Basic Cleanup
----------------
```jsx
function Component() {
  useEffect(() => {
    console.log('Effect setup');
    
    return () => {
      console.log('Effect cleanup');
    };
  });
  
  return <div>Component</div>;
}
```

3. Timer Cleanup
----------------
```jsx
function Timer() {
  const [seconds, setSeconds] = useState(0);
  
  useEffect(() => {
    const interval = setInterval(() => {
      setSeconds(s => s + 1);
    }, 1000);
    
    // Cleanup: clear interval when component unmounts
    return () => {
      clearInterval(interval);
    };
  }, []); // Empty array - set up once
  
  return <div>Seconds: {seconds}</div>;
}
```

4. Event Listener Cleanup
--------------------------
```jsx
function WindowSize() {
  const [width, setWidth] = useState(window.innerWidth);
  
  useEffect(() => {
    const handleResize = () => {
      setWidth(window.innerWidth);
    };
    
    window.addEventListener('resize', handleResize);
    
    // Cleanup: remove event listener
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  return <div>Window width: {width}px</div>;
}
```

5. Subscription Cleanup
-----------------------
```jsx
function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  
  useEffect(() => {
    const subscription = chatAPI.subscribe(roomId, (message) => {
      setMessages(prev => [...prev, message]);
    });
    
    // Cleanup: unsubscribe
    return () => {
      subscription.unsubscribe();
    };
  }, [roomId]);
  
  return (
    <div>
      {messages.map(msg => <p key={msg.id}>{msg.text}</p>)}
    </div>
  );
}
```


Common Use Cases
----------------

1. Document Title
-----------------
```jsx
function PageTitle({ title }) {
  useEffect(() => {
    document.title = title;
  }, [title]);
  
  return <h1>{title}</h1>;
}

// Usage
<PageTitle title="Home Page" />
<PageTitle title="About Us" />
```

2. Data Fetching
----------------
```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    setLoading(true);
    setError(null);
    
    fetch(`https://api.example.com/users/${userId}`)
      .then(response => {
        if (!response.ok) {
          throw new Error('Failed to fetch user');
        }
        return response.json();
      })
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        setError(err.message);
        setLoading(false);
      });
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  if (!user) return <div>No user found</div>;
  
  return (
    <div>
      <h2>{user.name}</h2>
      <p>{user.email}</p>
    </div>
  );
}
```

3. Data Fetching with Cleanup (Abort Controller)
-------------------------------------------------
```jsx
function UserProfile({ userId }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    const abortController = new AbortController();
    
    setLoading(true);
    
    fetch(`https://api.example.com/users/${userId}`, {
      signal: abortController.signal
    })
      .then(response => response.json())
      .then(data => {
        setUser(data);
        setLoading(false);
      })
      .catch(err => {
        if (err.name !== 'AbortError') {
          console.error('Fetch error:', err);
        }
      });
    
    // Cleanup: abort fetch if component unmounts or userId changes
    return () => {
      abortController.abort();
    };
  }, [userId]);
  
  if (loading) return <div>Loading...</div>;
  
  return <div>{user?.name}</div>;
}
```

4. Local Storage Sync
----------------------
```jsx
function TodoApp() {
  const [todos, setTodos] = useState(() => {
    // Load from localStorage on mount
    const saved = localStorage.getItem('todos');
    return saved ? JSON.parse(saved) : [];
  });
  
  // Save to localStorage whenever todos change
  useEffect(() => {
    localStorage.setItem('todos', JSON.stringify(todos));
  }, [todos]);
  
  const addTodo = (text) => {
    setTodos([...todos, { id: Date.now(), text, completed: false }]);
  };
  
  return <div>{/* Todo UI */}</div>;
}
```

5. Keyboard Event Listener
---------------------------
```jsx
function KeyboardShortcuts() {
  useEffect(() => {
    const handleKeyPress = (event) => {
      if (event.ctrlKey && event.key === 's') {
        event.preventDefault();
        console.log('Save shortcut pressed');
      }
    };
    
    document.addEventListener('keydown', handleKeyPress);
    
    return () => {
      document.removeEventListener('keydown', handleKeyPress);
    };
  }, []);
  
  return <div>Press Ctrl+S to save</div>;
}
```

6. Intersection Observer (Lazy Loading)
----------------------------------------
```jsx
function LazyImage({ src, alt }) {
  const [isVisible, setIsVisible] = useState(false);
  const imgRef = useRef(null);
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => {
      observer.disconnect();
    };
  }, []);
  
  return (
    <div ref={imgRef}>
      {isVisible ? (
        <img src={src} alt={alt} />
      ) : (
        <div>Loading...</div>
      )}
    </div>
  );
}
```

7. Web Socket Connection
-------------------------
```jsx
function LiveChat({ roomId }) {
  const [messages, setMessages] = useState([]);
  
  useEffect(() => {
    const ws = new WebSocket(`wss://api.example.com/chat/${roomId}`);
    
    ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      setMessages(prev => [...prev, message]);
    };
    
    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
    };
    
    // Cleanup: close connection
    return () => {
      ws.close();
    };
  }, [roomId]);
  
  return (
    <div>
      {messages.map(msg => (
        <p key={msg.id}>{msg.text}</p>
      ))}
    </div>
  );
}
```

8. Animation/Transition
-----------------------
```jsx
function FadeIn({ children }) {
  const [opacity, setOpacity] = useState(0);
  
  useEffect(() => {
    let progress = 0;
    const interval = setInterval(() => {
      progress += 0.05;
      setOpacity(progress);
      
      if (progress >= 1) {
        clearInterval(interval);
      }
    }, 50);
    
    return () => clearInterval(interval);
  }, []);
  
  return (
    <div style={{ opacity, transition: 'opacity 0.5s' }}>
      {children}
    </div>
  );
}
```


Multiple Effects
----------------

You can use multiple useEffect hooks in one component for separation of concerns.

```jsx
function UserDashboard({ userId }) {
  const [user, setUser] = useState(null);
  const [posts, setPosts] = useState([]);
  
  // Effect 1: Fetch user data
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]);
  
  // Effect 2: Fetch user posts
  useEffect(() => {
    fetch(`/api/users/${userId}/posts`)
      .then(res => res.json())
      .then(setPosts);
  }, [userId]);
  
  // Effect 3: Update document title
  useEffect(() => {
    if (user) {
      document.title = `${user.name}'s Profile`;
    }
  }, [user]);
  
  // Effect 4: Track analytics
  useEffect(() => {
    analytics.track('Page View', { page: 'UserDashboard', userId });
  }, [userId]);
  
  return <div>{/* UI */}</div>;
}
```


Common Pitfalls
---------------

1. Infinite Loop
----------------
```jsx
// ❌ WRONG - Infinite loop!
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    setCount(count + 1); // Triggers re-render
  }); // No dependency array - runs on every render!
  
  return <div>{count}</div>;
}

// ✅ CORRECT
function Component() {
  const [count, setCount] = useState(0);
  
  useEffect(() => {
    setCount(count + 1);
  }, []); // Only runs once
  
  return <div>{count}</div>;
}
```

2. Missing Dependencies
-----------------------
```jsx
// ❌ WRONG - Stale closure
function Component({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, []); // Missing userId dependency!
  
  return <div>{user?.name}</div>;
}

// ✅ CORRECT
function Component({ userId }) {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    fetch(`/api/users/${userId}`)
      .then(res => res.json())
      .then(setUser);
  }, [userId]); // Include all dependencies
  
  return <div>{user?.name}</div>;
}
```

3. Object/Array Dependencies
-----------------------------
```jsx
// ❌ WRONG - Creates new object every render
function Component({ filter }) {
  const [data, setData] = useState([]);
  
  useEffect(() => {
    fetchData(filter);
  }, [filter]); // If filter is an object, this runs every render
  
  return <div>{/* ... */}</div>;
}

// ✅ CORRECT - Depend on primitive values
function Component({ filter }) {
  const [data, setData] = useState([]);
  
  useEffect(() => {
    fetchData(filter);
  }, [filter.category, filter.minPrice]); // Use specific properties
  
  return <div>{/* ... */}</div>;
}
```


3.2 ADDITIONAL HOOKS
--------------------

useRef Hook
-----------

useRef returns a mutable object that persists across renders.

Use cases:
- Accessing DOM elements
- Storing mutable values that don't trigger re-renders
- Keeping track of previous values

1. DOM References
-----------------
```jsx
function TextInput() {
  const inputRef = useRef(null);
  
  const focusInput = () => {
    inputRef.current.focus();
  };
  
  return (
    <div>
      <input ref={inputRef} type="text" />
      <button onClick={focusInput}>Focus Input</button>
    </div>
  );
}
```

2. Multiple Refs
----------------
```jsx
function Form() {
  const nameRef = useRef(null);
  const emailRef = useRef(null);
  const passwordRef = useRef(null);
  
  const handleSubmit = (e) => {
    e.preventDefault();
    console.log({
      name: nameRef.current.value,
      email: emailRef.current.value,
      password: passwordRef.current.value
    });
  };
  
  return (
    <form onSubmit={handleSubmit}>
      <input ref={nameRef} placeholder="Name" />
      <input ref={emailRef} type="email" placeholder="Email" />
      <input ref={passwordRef} type="password" placeholder="Password" />
      <button type="submit">Submit</button>
    </form>
  );
}
```

3. Storing Mutable Values
--------------------------
```jsx
function StopWatch() {
  const [time, setTime] = useState(0);
  const [isRunning, setIsRunning] = useState(false);
  const intervalRef = useRef(null);
  
  const start = () => {
    if (!isRunning) {
      setIsRunning(true);
      intervalRef.current = setInterval(() => {
        setTime(t => t + 1);
      }, 1000);
    }
  };
  
  const stop = () => {
    setIsRunning(false);
    clearInterval(intervalRef.current);
  };
  
  const reset = () => {
    stop();
    setTime(0);
  };
  
  return (
    <div>
      <p>Time: {time}s</p>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

4. Previous Value
-----------------
```jsx
function usePrevious(value) {
  const ref = useRef();
  
  useEffect(() => {
    ref.current = value;
  }, [value]);
  
  return ref.current;
}

// Usage
function Counter() {
  const [count, setCount] = useState(0);
  const prevCount = usePrevious(count);
  
  return (
    <div>
      <p>Current: {count}</p>
      <p>Previous: {prevCount}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}
```

5. Ref vs State
---------------
```jsx
// State: Triggers re-render when changed
const [count, setCount] = useState(0);

// Ref: Doesn't trigger re-render when changed
const countRef = useRef(0);

// Update state (re-renders)
setCount(count + 1);

// Update ref (no re-render)
countRef.current = countRef.current + 1;
```


useContext Hook
---------------

useContext lets you read and subscribe to context without nesting.

1. Creating Context
-------------------
```jsx
import { createContext, useContext, useState } from 'react';

// Create context
const ThemeContext = createContext();

// Provider component
function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
  };
  
  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

// Custom hook for using context
function useTheme() {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
}

// Consumer component
function ThemedButton() {
  const { theme, toggleTheme } = useTheme();
  
  return (
    <button
      onClick={toggleTheme}
      style={{
        background: theme === 'light' ? '#fff' : '#333',
        color: theme === 'light' ? '#333' : '#fff'
      }}
    >
      Toggle Theme (Current: {theme})
    </button>
  );
}

// App
function App() {
  return (
    <ThemeProvider>
      <ThemedButton />
    </ThemeProvider>
  );
}
```

2. Authentication Context
--------------------------
```jsx
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // Check if user is logged in
    const token = localStorage.getItem('token');
    if (token) {
      fetchUser(token).then(setUser);
    }
    setLoading(false);
  }, []);
  
  const login = async (email, password) => {
    const user = await api.login(email, password);
    setUser(user);
    localStorage.setItem('token', user.token);
  };
  
  const logout = () => {
    setUser(null);
    localStorage.removeItem('token');
  };
  
  return (
    <AuthContext.Provider value={{ user, login, logout, loading }}>
      {children}
    </AuthContext.Provider>
  );
}

function useAuth() {
  return useContext(AuthContext);
}

// Usage
function Header() {
  const { user, logout } = useAuth();
  
  return (
    <header>
      {user ? (
        <>
          <span>Welcome, {user.name}</span>
          <button onClick={logout}>Logout</button>
        </>
      ) : (
        <a href="/login">Login</a>
      )}
    </header>
  );
}
```

3. Multiple Contexts
--------------------
```jsx
function App() {
  return (
    <AuthProvider>
      <ThemeProvider>
        <LanguageProvider>
          <MainApp />
        </LanguageProvider>
      </ThemeProvider>
    </AuthProvider>
  );
}

function Profile() {
  const { user } = useAuth();
  const { theme } = useTheme();
  const { language } = useLanguage();
  
  return <div>{/* Use all contexts */}</div>;
}
```


useReducer Hook
---------------

useReducer is an alternative to useState for complex state logic.

When to use useReducer:
- Complex state logic
- Multiple sub-values
- Next state depends on previous
- State transitions follow patterns

1. Basic Counter Example
-------------------------
```jsx
import { useReducer } from 'react';

// Reducer function
function counterReducer(state, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { count: state.count + 1 };
    case 'DECREMENT':
      return { count: state.count - 1 };
    case 'RESET':
      return { count: 0 };
    default:
      return state;
  }
}

function Counter() {
  const [state, dispatch] = useReducer(counterReducer, { count: 0 });
  
  return (
    <div>
      <p>Count: {state.count}</p>
      <button onClick={() => dispatch({ type: 'INCREMENT' })}>+</button>
      <button onClick={() => dispatch({ type: 'DECREMENT' })}>-</button>
      <button onClick={() => dispatch({ type: 'RESET' })}>Reset</button>
    </div>
  );
}
```

2. Todo List with useReducer
-----------------------------
```jsx
function todoReducer(state, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return [
        ...state,
        {
          id: Date.now(),
          text: action.payload,
          completed: false
        }
      ];
    
    case 'TOGGLE_TODO':
      return state.map(todo =>
        todo.id === action.payload
          ? { ...todo, completed: !todo.completed }
          : todo
      );
    
    case 'DELETE_TODO':
      return state.filter(todo => todo.id !== action.payload);
    
    case 'EDIT_TODO':
      return state.map(todo =>
        todo.id === action.payload.id
          ? { ...todo, text: action.payload.text }
          : todo
      );
    
    default:
      return state;
  }
}

function TodoApp() {
  const [todos, dispatch] = useReducer(todoReducer, []);
  const [input, setInput] = useState('');
  
  const handleAdd = () => {
    if (input.trim()) {
      dispatch({ type: 'ADD_TODO', payload: input });
      setInput('');
    }
  };
  
  return (
    <div>
      <input
        value={input}
        onChange={(e) => setInput(e.target.value)}
        onKeyPress={(e) => e.key === 'Enter' && handleAdd()}
      />
      <button onClick={handleAdd}>Add</button>
      
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => dispatch({ type: 'TOGGLE_TODO', payload: todo.id })}
            />
            <span style={{ textDecoration: todo.completed ? 'line-through' : 'none' }}>
              {todo.text}
            </span>
            <button onClick={() => dispatch({ type: 'DELETE_TODO', payload: todo.id })}>
              Delete
            </button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

3. Form with useReducer
------------------------
```jsx
function formReducer(state, action) {
  switch (action.type) {
    case 'UPDATE_FIELD':
      return {
        ...state,
        [action.field]: action.value
      };
    
    case 'RESET':
      return action.payload;
    
    default:
      return state;
  }
}

function UserForm() {
  const initialState = {
    name: '',
    email: '',
    age: '',
    country: 'USA'
  };
  
  const [formData, dispatch] = useReducer(formReducer, initialState);
  
  const handleChange = (e) => {
    dispatch({
      type: 'UPDATE_FIELD',
      field: e.target.name,
      value: e.target.value
    });
  };
  
  const handleReset = () => {
    dispatch({ type: 'RESET', payload: initialState });
  };
  
  return (
    <form>
      <input
        name="name"
        value={formData.name}
        onChange={handleChange}
      />
      {/* More inputs... */}
      <button type="button" onClick={handleReset}>Reset</button>
    </form>
  );
}
```


useMemo Hook
------------

useMemo caches the result of a calculation between re-renders.

Use when:
- Expensive calculations
- Referential equality matters
- Avoiding unnecessary re-renders

1. Expensive Calculation
-------------------------
```jsx
import { useMemo } from 'react';

function ExpensiveComponent({ numbers }) {
  const sum = useMemo(() => {
    console.log('Calculating sum...');
    return numbers.reduce((a, b) => a + b, 0);
  }, [numbers]); // Only recalculate if numbers change
  
  return <div>Sum: {sum}</div>;
}
```

2. Filtering Large Lists
-------------------------
```jsx
function UserList({ users, searchTerm }) {
  const filteredUsers = useMemo(() => {
    console.log('Filtering users...');
    return users.filter(user =>
      user.name.toLowerCase().includes(searchTerm.toLowerCase())
    );
  }, [users, searchTerm]);
  
  return (
    <ul>
      {filteredUsers.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}
```

3. Avoiding Object Recreation
------------------------------
```jsx
function Parent() {
  const [count, setCount] = useState(0);
  
  // ❌ New object every render
  const config = { theme: 'dark', count };
  
  // ✅ Memoized - same object unless count changes
  const config = useMemo(() => ({
    theme: 'dark',
    count
  }), [count]);
  
  return <Child config={config} />;
}
```


useCallback Hook
----------------

useCallback caches a function definition between re-renders.

Use when:
- Passing callbacks to optimized child components
- Functions are dependencies of other hooks
- Avoiding unnecessary re-renders

1. Preventing Child Re-renders
-------------------------------
```jsx
import { memo, useCallback } from 'react';

const Child = memo(({ onIncrement }) => {
  console.log('Child rendered');
  return <button onClick={onIncrement}>Increment</button>;
});

function Parent() {
  const [count, setCount] = useState(0);
  const [other, setOther] = useState(0);
  
  // ❌ New function every render - Child re-renders unnecessarily
  const handleIncrement = () => setCount(c => c + 1);
  
  // ✅ Memoized function - Child only re-renders when necessary
  const handleIncrement = useCallback(() => {
    setCount(c => c + 1);
  }, []);
  
  return (
    <div>
      <p>Count: {count}</p>
      <p>Other: {other}</p>
      <Child onIncrement={handleIncrement} />
      <button onClick={() => setOther(o => o + 1)}>Update Other</button>
    </div>
  );
}
```

2. Function as Dependency
--------------------------
```jsx
function SearchComponent({ apiUrl }) {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  
  const fetchResults = useCallback(async () => {
    const response = await fetch(`${apiUrl}?q=${query}`);
    const data = await response.json();
    setResults(data);
  }, [apiUrl, query]);
  
  useEffect(() => {
    if (query) {
      fetchResults();
    }
  }, [fetchResults]); // Safe to use as dependency
  
  return <div>{/* UI */}</div>;
}
```

3. Event Handlers with Parameters
----------------------------------
```jsx
function ItemList({ items }) {
  const handleDelete = useCallback((id) => {
    console.log('Deleting', id);
    // Delete logic
  }, []);
  
  return (
    <ul>
      {items.map(item => (
        <Item
          key={item.id}
          item={item}
          onDelete={handleDelete}
        />
      ))}
    </ul>
  );
}
```


3.3 CUSTOM HOOKS
----------------

Custom hooks let you extract component logic into reusable functions.

Rules:
- Must start with "use"
- Can call other hooks
- Return values or functions
- Share logic, not state

1. Basic Custom Hook
--------------------
```jsx
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  
  const increment = () => setCount(c => c + 1);
  const decrement = () => setCount(c => c - 1);
  const reset = () => setCount(initialValue);
  
  return { count, increment, decrement, reset };
}

// Usage
function Counter() {
  const { count, increment, decrement, reset } = useCounter(10);
  
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
      <button onClick={decrement}>-</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}
```

2. useLocalStorage
------------------
```jsx
function useLocalStorage(key, initialValue) {
  const [value, setValue] = useState(() => {
    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.error(error);
      return initialValue;
    }
  });
  
  const setStoredValue = (newValue) => {
    try {
      setValue(newValue);
      window.localStorage.setItem(key, JSON.stringify(newValue));
    } catch (error) {
      console.error(error);
    }
  };
  
  return [value, setStoredValue];
}

// Usage
function App() {
  const [name, setName] = useLocalStorage('name', '');
  const [theme, setTheme] = useLocalStorage('theme', 'light');
  
  return (
    <div>
      <input value={name} onChange={(e) => setName(e.target.value)} />
      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
        Toggle Theme
      </button>
    </div>
  );
}
```

3. useFetch
-----------
```jsx
function useFetch(url) {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  
  useEffect(() => {
    const abortController = new AbortController();
    
    setLoading(true);
    setError(null);
    
    fetch(url, { signal: abortController.signal })
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return response.json();
      })
      .then(data => {
        setData(data);
        setLoading(false);
      })
      .catch(error => {
        if (error.name !== 'AbortError') {
          setError(error.message);
          setLoading(false);
        }
      });
    
    return () => abortController.abort();
  }, [url]);
  
  return { data, loading, error };
}

// Usage
function UserProfile({ userId }) {
  const { data: user, loading, error } = useFetch(
    `https://api.example.com/users/${userId}`
  );
  
  if (loading) return <div>Loading...</div>;
  if (error) return <div>Error: {error}</div>;
  
  return <div>{user.name}</div>;
}
```

4. useDebounce
--------------
```jsx
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);
  
  useEffect(() => {
    const timer = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);
    
    return () => clearTimeout(timer);
  }, [value, delay]);
  
  return debouncedValue;
}

// Usage
function SearchBar() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 500);
  
  useEffect(() => {
    if (debouncedSearchTerm) {
      // Perform search
      console.log('Searching for:', debouncedSearchTerm);
    }
  }, [debouncedSearchTerm]);
  
  return (
    <input
      value={searchTerm}
      onChange={(e) => setSearchTerm(e.target.value)}
      placeholder="Search..."
    />
  );
}
```

5. useToggle
------------
```jsx
function useToggle(initialValue = false) {
  const [value, setValue] = useState(initialValue);
  
  const toggle = useCallback(() => {
    setValue(v => !v);
  }, []);
  
  return [value, toggle];
}

// Usage
function Modal() {
  const [isOpen, toggleOpen] = useToggle(false);
  
  return (
    <div>
      <button onClick={toggleOpen}>Open Modal</button>
      {isOpen && (
        <div className="modal">
          <h2>Modal Content</h2>
          <button onClick={toggleOpen}>Close</button>
        </div>
      )}
    </div>
  );
}
```

6. useWindowSize
----------------
```jsx
function useWindowSize() {
  const [size, setSize] = useState({
    width: window.innerWidth,
    height: window.innerHeight
  });
  
  useEffect(() => {
    const handleResize = () => {
      setSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    };
    
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);
  
  return size;
}

// Usage
function ResponsiveComponent() {
  const { width, height } = useWindowSize();
  
  return (
    <div>
      <p>Window size: {width} x {height}</p>
      {width < 768 ? <MobileView /> : <DesktopView />}
    </div>
  );
}
```

7. useOnClickOutside
--------------------
```jsx
function useOnClickOutside(ref, handler) {
  useEffect(() => {
    const listener = (event) => {
      if (!ref.current || ref.current.contains(event.target)) {
        return;
      }
      handler(event);
    };
    
    document.addEventListener('mousedown', listener);
    document.addEventListener('touchstart', listener);
    
    return () => {
      document.removeEventListener('mousedown', listener);
      document.removeEventListener('touchstart', listener);
    };
  }, [ref, handler]);
}

// Usage
function Dropdown() {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);
  
  useOnClickOutside(dropdownRef, () => setIsOpen(false));
  
  return (
    <div ref={dropdownRef}>
      <button onClick={() => setIsOpen(!isOpen)}>Toggle</button>
      {isOpen && <div className="dropdown-menu">Menu items</div>}
    </div>
  );
}
```


Hook Composition
----------------

Combining custom hooks for complex functionality:

```jsx
function useApi(url) {
  const { data, loading, error } = useFetch(url);
  const [savedData, setSavedData] = useLocalStorage(`cache-${url}`, null);
  
  useEffect(() => {
    if (data) {
      setSavedData(data);
    }
  }, [data, setSavedData]);
  
  return {
    data: data || savedData,
    loading,
    error
  };
}

function useSearchWithDebounce() {
  const [searchTerm, setSearchTerm] = useState('');
  const debouncedSearchTerm = useDebounce(searchTerm, 300);
  const { data, loading, error } = useApi(
    `/api/search?q=${debouncedSearchTerm}`
  );
  
  return {
    searchTerm,
    setSearchTerm,
    results: data,
    loading,
    error
  };
}
```


PRACTICE EXERCISES
------------------

Exercise 1: Clock Component
---------------------------
Create a digital clock that:
- Updates every second
- Shows hours, minutes, seconds
- Can be paused/resumed
- Cleanup on unmount

Exercise 2: Data Dashboard
--------------------------
Build a dashboard that:
- Fetches data from API on mount
- Refetches every 30 seconds
- Shows loading state
- Handles errors
- Cancels pending requests on unmount

Exercise 3: Form with Auto-save
-------------------------------
Create a form that:
- Auto-saves to localStorage
- Debounces saves
- Shows save status
- Loads saved data on mount

Exercise 4: Infinite Scroll
---------------------------
Implement infinite scrolling:
- Load more items when near bottom
- Use Intersection Observer
- Show loading indicator
- Handle errors

Exercise 5: Custom Hook Library
-------------------------------
Create custom hooks for:
- useAsync (async operations)
- useArray (array manipulation)
- useTimeout/useInterval
- usePrevious
- useMediaQuery


COMMON MISTAKES & TIPS
-----------------------

Common Mistakes:
1. Missing cleanup functions (memory leaks)
2. Incorrect dependencies in useEffect
3. Fetching data without handling race conditions
4. Creating functions/objects in render without memoization
5. Overusing useMemo/useCallback
6. Not handling loading and error states
7. Forgetting to handle component unmount

Tips:
1. Always clean up side effects
2. List all dependencies in dependency array
3. Use AbortController for fetch cancellation
4. Only memoize when there's actual performance benefit
5. Extract complex logic into custom hooks
6. Use ESLint plugin for React hooks
7. Consider using libraries like React Query for data fetching
8. Keep effects focused and single-purpose


NEXT STEPS
----------

You've completed Module 3! You should now understand:
✓ Using useEffect for side effects
✓ Effect dependencies and cleanup
✓ useRef for DOM access and mutable values
✓ useContext for consuming context
✓ useReducer for complex state logic
✓ useMemo and useCallback for optimization
✓ Creating custom hooks for reusable logic

Next up: Module 4 - Advanced Patterns
Learn about Context API, Higher-Order Components, render props, and code splitting.
